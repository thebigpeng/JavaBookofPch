## 1.八大基本内置数据类型

| 类型名称    | 大小                                                         | 最小值                      | 最大值                        | 默认值    |
| ----------- | ------------------------------------------------------------ | --------------------------- | ----------------------------- | :-------- |
| **byte**    | 8位、有符号的，以二进制补码表示的整数                        | **-128（-2^7）**            | **127（2^7-1）**              | 0         |
| **short**   | short 数据类型是 16 位、有符号的以二进制补码表示的整数       | **-32768（-2^15）**         | **32767（2^15 - 1）**         | 0         |
| **int**     | int 数据类型是32位、有符号的以二进制补码表示的整数           | **-2,147,483,648（-2^31）** | **2,147,483,647（2^31 - 1）** | 0         |
| **long**    | long 数据类型是 64 位、有符号的以二进制补码表示的整数        | **-2^63**                   | **2^63 -1**                   | 0         |
| **float**   | 数据类型是单精度、32位、符合IEEE 754标准的浮点数             |                             |                               | **0.0f**  |
| **double**  | double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；   |                             |                               | **0.0d**  |
| **char**    | 单一的 16 位 Unicode 字符                                    | **\u0000**                  | **\uffff**                    | **null**  |
| **boolean** | <font color='cornflowerblue'>表示一位的信息，未精确定义大小，所有的boolean值在编译后用JVM中的int数据类型来代替，boolean数组则会被编码成JVM中byte数组，每个元素占8位</font> | 只有两个取值：true 和 false |                               | **false** |

对应的封装器类如下：

| 简单类型   | boolean | byte | char      | short | Int     | long | float | double | void |
| ---------- | ------- | ---- | --------- | ----- | ------- | ---- | ----- | ------ | ---- |
| 二进制位数 | 1       | 8    | 16        | 16    | 32      | 64   | 32    | 64     | --   |
| 封装器类   | Boolean | Byte | Character | Short | Integer | Long | Float | Double | Void |

### 装箱与拆箱

<font color='cornflowerblue'>装箱</font>：就是把基本数据类型转换为包装类(封装器类)

<font color='cornflowerblue'>拆箱</font>：就是把包装类转换为基本数据类型

通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。其他包装类型的原理类似。

Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。

谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。

1. 第一种方式不会触发自动装箱的过程；而第二种方式会触发；
2. 在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。

**Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。** 为啥把缓存设置为[-128，127]区间？（[参见 issue/461](https://github.com/Snailclimb/JavaGuide/issues/461)）性能和资源之间的权衡。

> 当 "=="运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。

## 2.引用类型

- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。
- 例子：Site site = new Site("Runoob")。

Java有 **5种引用类型**（对象类型）：类 接口 数组 枚举 标注

## 3.自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

数据类型转换必须满足如下规则：

-  不能对boolean类型进行类型转换。
-  不能把对象类型转换成不相关类的对象。
-  在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
-  转换过程中可能导致溢出或损失精度。

## 4.强制类型转换

- 条件是转换的数据类型必须是兼容的。
- 格式：`(type)value type`是要强制类型转换后的数据类型